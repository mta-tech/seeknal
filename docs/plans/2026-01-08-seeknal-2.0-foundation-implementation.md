# Seeknal 2.0 Foundation Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the core DAG infrastructure with `ref()`, `source()`, `use_transform()`, `use_rule()` dependency declarations and manifest generation.

**Architecture:** Create a dependency tracking system that intercepts calls to `ref()`, `source()`, etc., registers them in a global registry, and generates a manifest.json during `seeknal parse`. The manifest contains all nodes, their dependencies, and metadata for lineage visualization.

**Tech Stack:** Python 3.11+, Typer (CLI), SQLModel, Pydantic, JSON for manifest

---

## Phase 1 Overview

This phase builds the foundation:

1. **Task 1-3:** Core dependency functions (`ref`, `source`, `use_transform`, `use_rule`)
2. **Task 4-5:** Node registry and manifest data structures
3. **Task 6-8:** `seeknal parse` command with validation
4. **Task 9-10:** Diff detection and display
5. **Task 11-12:** Selection syntax for `seeknal run`

---

## Task 1: Create Dependency Registry Module

**Files:**
- Create: `src/seeknal/dag/__init__.py`
- Create: `src/seeknal/dag/registry.py`
- Test: `src/tests/dag/test_registry.py`

**Step 1: Create the dag package directory**

```bash
mkdir -p src/seeknal/dag
mkdir -p src/tests/dag
touch src/seeknal/dag/__init__.py
touch src/tests/dag/__init__.py
```

**Step 2: Write the failing test for DependencyRegistry**

Create `src/tests/dag/test_registry.py`:

```python
"""Tests for the dependency registry."""
import pytest
from seeknal.dag.registry import DependencyRegistry, DependencyType


class TestDependencyRegistry:
    """Test the DependencyRegistry class."""

    def test_registry_is_singleton(self):
        """Registry should be a singleton."""
        reg1 = DependencyRegistry.get_instance()
        reg2 = DependencyRegistry.get_instance()
        assert reg1 is reg2

    def test_registry_reset(self):
        """Registry can be reset for testing."""
        reg = DependencyRegistry.get_instance()
        reg.register_dependency("node1", "source", "traffic_day", DependencyType.SOURCE)
        reg.reset()
        assert len(reg.get_all_dependencies()) == 0

    def test_register_source_dependency(self):
        """Can register a source dependency."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.register_dependency(
            node_id="feature_group.user_features",
            dependency_id="traffic_day",
            dependency_type=DependencyType.SOURCE
        )

        deps = reg.get_dependencies_for_node("feature_group.user_features")
        assert len(deps) == 1
        assert deps[0].dependency_id == "traffic_day"
        assert deps[0].dependency_type == DependencyType.SOURCE

    def test_register_ref_dependency(self):
        """Can register a ref dependency."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.register_dependency(
            node_id="model.churn_predictor",
            dependency_id="feature_group.user_features",
            dependency_type=DependencyType.REF
        )

        deps = reg.get_dependencies_for_node("model.churn_predictor")
        assert len(deps) == 1
        assert deps[0].dependency_type == DependencyType.REF

    def test_register_transform_dependency(self):
        """Can register a transform dependency."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.register_dependency(
            node_id="feature_group.user_features",
            dependency_id="rename_subscriber_type",
            dependency_type=DependencyType.TRANSFORM
        )

        deps = reg.get_dependencies_for_node("feature_group.user_features")
        assert len(deps) == 1
        assert deps[0].dependency_type == DependencyType.TRANSFORM

    def test_register_rule_dependency(self):
        """Can register a rule dependency."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.register_dependency(
            node_id="feature_group.user_features",
            dependency_id="callExpression",
            dependency_type=DependencyType.RULE
        )

        deps = reg.get_dependencies_for_node("feature_group.user_features")
        assert len(deps) == 1
        assert deps[0].dependency_type == DependencyType.RULE

    def test_get_all_dependencies(self):
        """Can get all registered dependencies."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.register_dependency("node1", "source1", DependencyType.SOURCE)
        reg.register_dependency("node1", "node2", DependencyType.REF)
        reg.register_dependency("node2", "source2", DependencyType.SOURCE)

        all_deps = reg.get_all_dependencies()
        assert len(all_deps) == 3

    def test_set_current_node(self):
        """Can set the current node context."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.set_current_node("feature_group.user_features")
        assert reg.get_current_node() == "feature_group.user_features"

    def test_clear_current_node(self):
        """Can clear the current node context."""
        reg = DependencyRegistry.get_instance()
        reg.reset()

        reg.set_current_node("feature_group.user_features")
        reg.clear_current_node()
        assert reg.get_current_node() is None
```

**Step 3: Run test to verify it fails**

```bash
cd /Users/fitrakacamarga/project/mta/signal/.worktrees/seeknal-2.0-foundation
uv run pytest src/tests/dag/test_registry.py -v
```

Expected: FAIL with "ModuleNotFoundError: No module named 'seeknal.dag'"

**Step 4: Write minimal implementation**

Create `src/seeknal/dag/registry.py`:

```python
"""
Dependency Registry for DAG tracking.

This module provides a singleton registry that tracks dependencies
between nodes in the Seeknal DAG. When ref(), source(), use_transform(),
or use_rule() are called, they register their dependencies here.
"""
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional
from threading import Lock


class DependencyType(Enum):
    """Type of dependency relationship."""
    SOURCE = "source"
    REF = "ref"
    TRANSFORM = "transform"
    RULE = "rule"
    AGGREGATION = "aggregation"


@dataclass
class Dependency:
    """A single dependency relationship."""
    node_id: str
    dependency_id: str
    dependency_type: DependencyType
    params: Dict = field(default_factory=dict)


class DependencyRegistry:
    """
    Singleton registry for tracking DAG dependencies.

    This registry is populated during code execution when ref(), source(),
    use_transform(), and use_rule() functions are called. It maintains
    the dependency graph that will be serialized to manifest.json.

    Thread-safe for concurrent access.
    """

    _instance: Optional["DependencyRegistry"] = None
    _lock: Lock = Lock()

    def __init__(self):
        self._dependencies: List[Dependency] = []
        self._current_node: Optional[str] = None
        self._node_dependencies: Dict[str, List[Dependency]] = {}

    @classmethod
    def get_instance(cls) -> "DependencyRegistry":
        """Get the singleton instance."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    def reset(self) -> None:
        """Reset the registry. Useful for testing."""
        with self._lock:
            self._dependencies = []
            self._current_node = None
            self._node_dependencies = {}

    def set_current_node(self, node_id: str) -> None:
        """Set the current node context for dependency registration."""
        self._current_node = node_id
        if node_id not in self._node_dependencies:
            self._node_dependencies[node_id] = []

    def get_current_node(self) -> Optional[str]:
        """Get the current node context."""
        return self._current_node

    def clear_current_node(self) -> None:
        """Clear the current node context."""
        self._current_node = None

    def register_dependency(
        self,
        node_id: str,
        dependency_id: str,
        dependency_type: DependencyType,
        params: Optional[Dict] = None
    ) -> Dependency:
        """
        Register a dependency.

        Args:
            node_id: The node that has the dependency
            dependency_id: The ID of the dependency (source name, node name, etc.)
            dependency_type: Type of dependency (SOURCE, REF, TRANSFORM, RULE)
            params: Optional parameters passed to the dependency

        Returns:
            The created Dependency object
        """
        dep = Dependency(
            node_id=node_id,
            dependency_id=dependency_id,
            dependency_type=dependency_type,
            params=params or {}
        )

        with self._lock:
            self._dependencies.append(dep)
            if node_id not in self._node_dependencies:
                self._node_dependencies[node_id] = []
            self._node_dependencies[node_id].append(dep)

        return dep

    def get_dependencies_for_node(self, node_id: str) -> List[Dependency]:
        """Get all dependencies for a specific node."""
        return self._node_dependencies.get(node_id, [])

    def get_all_dependencies(self) -> List[Dependency]:
        """Get all registered dependencies."""
        return self._dependencies.copy()

    def get_dependency_graph(self) -> Dict[str, List[str]]:
        """
        Get the dependency graph as adjacency list.

        Returns:
            Dict mapping node_id to list of dependency_ids
        """
        graph = {}
        for node_id, deps in self._node_dependencies.items():
            graph[node_id] = [d.dependency_id for d in deps]
        return graph
```

Update `src/seeknal/dag/__init__.py`:

```python
"""DAG dependency tracking for Seeknal 2.0."""
from seeknal.dag.registry import DependencyRegistry, DependencyType, Dependency

__all__ = ["DependencyRegistry", "DependencyType", "Dependency"]
```

**Step 5: Run test to verify it passes**

```bash
uv run pytest src/tests/dag/test_registry.py -v
```

Expected: PASS (9 tests)

**Step 6: Commit**

```bash
git add src/seeknal/dag/ src/tests/dag/
git commit -m "feat(dag): add dependency registry for DAG tracking

- Add DependencyRegistry singleton for tracking dependencies
- Support SOURCE, REF, TRANSFORM, RULE dependency types
- Thread-safe implementation with locking
- Include comprehensive tests"
```

---

## Task 2: Create Core Dependency Functions

**Files:**
- Create: `src/seeknal/dag/functions.py`
- Modify: `src/seeknal/dag/__init__.py`
- Test: `src/tests/dag/test_functions.py`

**Step 1: Write the failing test**

Create `src/tests/dag/test_functions.py`:

```python
"""Tests for dependency declaration functions."""
import pytest
import pandas as pd
from seeknal.dag.functions import source, ref, use_transform, use_rule
from seeknal.dag.registry import DependencyRegistry, DependencyType


class TestSourceFunction:
    """Test the source() function."""

    def setup_method(self):
        """Reset registry before each test."""
        DependencyRegistry.get_instance().reset()

    def test_source_registers_dependency(self):
        """source() should register a SOURCE dependency."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = source("traffic_day")

        deps = reg.get_dependencies_for_node("feature_group.test")
        assert len(deps) == 1
        assert deps[0].dependency_id == "traffic_day"
        assert deps[0].dependency_type == DependencyType.SOURCE

    def test_source_returns_source_reference(self):
        """source() should return a SourceReference object."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = source("traffic_day")

        assert result.name == "traffic_day"
        assert result.source_type == "common_config"

    def test_source_with_inline_declaration(self):
        """source() should support inline source declaration."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = source("hive", "eureka_feateng.user_events")

        assert result.name == "eureka_feateng.user_events"
        assert result.source_type == "hive"


class TestRefFunction:
    """Test the ref() function."""

    def setup_method(self):
        """Reset registry before each test."""
        DependencyRegistry.get_instance().reset()

    def test_ref_registers_dependency(self):
        """ref() should register a REF dependency."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("model.churn_predictor")

        result = ref("user_features")

        deps = reg.get_dependencies_for_node("model.churn_predictor")
        assert len(deps) == 1
        assert deps[0].dependency_id == "user_features"
        assert deps[0].dependency_type == DependencyType.REF

    def test_ref_returns_node_reference(self):
        """ref() should return a NodeReference object."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("model.churn_predictor")

        result = ref("user_features")

        assert result.name == "user_features"


class TestUseTransformFunction:
    """Test the use_transform() function."""

    def setup_method(self):
        """Reset registry before each test."""
        DependencyRegistry.get_instance().reset()

    def test_use_transform_registers_dependency(self):
        """use_transform() should register a TRANSFORM dependency."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        df = pd.DataFrame({"a": [1, 2, 3]})
        result = use_transform("rename_subscriber_type", df)

        deps = reg.get_dependencies_for_node("feature_group.test")
        assert len(deps) == 1
        assert deps[0].dependency_id == "rename_subscriber_type"
        assert deps[0].dependency_type == DependencyType.TRANSFORM

    def test_use_transform_with_params(self):
        """use_transform() should pass through parameters."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        df = pd.DataFrame({"a": [1, 2, 3]})
        result = use_transform(
            "rename_column_values",
            df,
            input_col="a",
            output_col="b"
        )

        deps = reg.get_dependencies_for_node("feature_group.test")
        assert deps[0].params["input_col"] == "a"
        assert deps[0].params["output_col"] == "b"


class TestUseRuleFunction:
    """Test the use_rule() function."""

    def setup_method(self):
        """Reset registry before each test."""
        DependencyRegistry.get_instance().reset()

    def test_use_rule_registers_dependency(self):
        """use_rule() should register a RULE dependency."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = use_rule("callExpression")

        deps = reg.get_dependencies_for_node("feature_group.test")
        assert len(deps) == 1
        assert deps[0].dependency_id == "callExpression"
        assert deps[0].dependency_type == DependencyType.RULE

    def test_use_rule_with_params(self):
        """use_rule() should support parameterized rules."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = use_rule("filter_by_service", service_type="Voice")

        deps = reg.get_dependencies_for_node("feature_group.test")
        assert deps[0].params["service_type"] == "Voice"

    def test_use_rule_returns_expression(self):
        """use_rule() should return a RuleExpression for filtering."""
        reg = DependencyRegistry.get_instance()
        reg.set_current_node("feature_group.test")

        result = use_rule("callExpression")

        assert result.rule_id == "callExpression"
```

**Step 2: Run test to verify it fails**

```bash
uv run pytest src/tests/dag/test_functions.py -v
```

Expected: FAIL with "ModuleNotFoundError"

**Step 3: Write minimal implementation**

Create `src/seeknal/dag/functions.py`:

```python
"""
Core dependency declaration functions.

These functions are the primary API for declaring dependencies in Seeknal 2.0:
- source() - Reference external data sources
- ref() - Reference other nodes (feature groups, transforms, models)
- use_transform() - Apply a reusable transformation
- use_rule() - Apply a reusable business rule
"""
from dataclasses import dataclass, field
from typing import Any, Dict, Optional, Union
import pandas as pd

from seeknal.dag.registry import DependencyRegistry, DependencyType


@dataclass
class SourceReference:
    """Reference to a data source."""
    name: str
    source_type: str = "common_config"
    params: Dict[str, Any] = field(default_factory=dict)

    def to_dataframe(self) -> pd.DataFrame:
        """Load the source as a DataFrame (placeholder for actual implementation)."""
        # This will be implemented to actually load data
        raise NotImplementedError("Source loading not yet implemented")


@dataclass
class NodeReference:
    """Reference to another node in the DAG."""
    name: str
    params: Dict[str, Any] = field(default_factory=dict)

    def offline(self, start_date: Optional[str] = None, end_date: Optional[str] = None) -> "NodeReference":
        """Get offline store data for this node."""
        self.params["store"] = "offline"
        self.params["start_date"] = start_date
        self.params["end_date"] = end_date
        return self

    def online(self) -> "NodeReference":
        """Get online store data for this node."""
        self.params["store"] = "online"
        return self


@dataclass
class RuleExpression:
    """Expression from a business rule."""
    rule_id: str
    params: Dict[str, Any] = field(default_factory=dict)

    def to_sql(self) -> str:
        """Convert rule to SQL expression (placeholder)."""
        # This will be implemented to resolve rule from common config
        raise NotImplementedError("Rule resolution not yet implemented")


def source(
    source_id_or_type: str,
    table_or_path: Optional[str] = None,
    **params
) -> SourceReference:
    """
    Declare a dependency on a data source.

    Can be used in two ways:
    1. Reference from common config: source("traffic_day")
    2. Inline declaration: source("hive", "db.table")

    Args:
        source_id_or_type: Either source ID from common config, or source type
        table_or_path: Table name or path (for inline declaration)
        **params: Additional parameters

    Returns:
        SourceReference object
    """
    registry = DependencyRegistry.get_instance()
    current_node = registry.get_current_node()

    if table_or_path is not None:
        # Inline declaration: source("hive", "db.table")
        source_type = source_id_or_type
        source_name = table_or_path
        ref = SourceReference(
            name=source_name,
            source_type=source_type,
            params=params
        )
    else:
        # Common config reference: source("traffic_day")
        source_name = source_id_or_type
        ref = SourceReference(
            name=source_name,
            source_type="common_config",
            params=params
        )

    # Register the dependency if we have a current node context
    if current_node:
        registry.register_dependency(
            node_id=current_node,
            dependency_id=f"source.{source_name}",
            dependency_type=DependencyType.SOURCE,
            params=params
        )

    return ref


def ref(node_name: str, **params) -> NodeReference:
    """
    Declare a dependency on another node.

    Creates a DAG edge from the current node to the referenced node.

    Args:
        node_name: Name of the node to reference
        **params: Additional parameters

    Returns:
        NodeReference object
    """
    registry = DependencyRegistry.get_instance()
    current_node = registry.get_current_node()

    node_ref = NodeReference(name=node_name, params=params)

    # Register the dependency if we have a current node context
    if current_node:
        registry.register_dependency(
            node_id=current_node,
            dependency_id=node_name,
            dependency_type=DependencyType.REF,
            params=params
        )

    return node_ref


def use_transform(
    transform_id: str,
    df: Any,
    **params
) -> Any:
    """
    Apply a reusable transformation from common config.

    Args:
        transform_id: ID of the transformation in common config
        df: DataFrame to transform
        **params: Parameters to pass to the transformation (for templating)

    Returns:
        Transformed DataFrame (currently returns input unchanged)
    """
    registry = DependencyRegistry.get_instance()
    current_node = registry.get_current_node()

    # Register the dependency if we have a current node context
    if current_node:
        registry.register_dependency(
            node_id=current_node,
            dependency_id=f"transform.{transform_id}",
            dependency_type=DependencyType.TRANSFORM,
            params=params
        )

    # TODO: Actually apply the transformation from common config
    # For now, just return the input DataFrame
    return df


def use_rule(rule_id: str, **params) -> RuleExpression:
    """
    Get a business rule expression from common config.

    Args:
        rule_id: ID of the rule in common config
        **params: Parameters for rule templating

    Returns:
        RuleExpression that can be used for filtering
    """
    registry = DependencyRegistry.get_instance()
    current_node = registry.get_current_node()

    # Register the dependency if we have a current node context
    if current_node:
        registry.register_dependency(
            node_id=current_node,
            dependency_id=f"rule.{rule_id}",
            dependency_type=DependencyType.RULE,
            params=params
        )

    return RuleExpression(rule_id=rule_id, params=params)
```

Update `src/seeknal/dag/__init__.py`:

```python
"""DAG dependency tracking for Seeknal 2.0."""
from seeknal.dag.registry import DependencyRegistry, DependencyType, Dependency
from seeknal.dag.functions import (
    source,
    ref,
    use_transform,
    use_rule,
    SourceReference,
    NodeReference,
    RuleExpression,
)

__all__ = [
    "DependencyRegistry",
    "DependencyType",
    "Dependency",
    "source",
    "ref",
    "use_transform",
    "use_rule",
    "SourceReference",
    "NodeReference",
    "RuleExpression",
]
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/dag/test_functions.py -v
```

Expected: PASS (11 tests)

**Step 5: Commit**

```bash
git add src/seeknal/dag/ src/tests/dag/
git commit -m "feat(dag): add core dependency functions ref, source, use_transform, use_rule

- source() for data source dependencies (common config or inline)
- ref() for node references (feature groups, models, etc.)
- use_transform() for reusable transformations
- use_rule() for business rule expressions
- All functions register dependencies in the global registry"
```

---

## Task 3: Create Manifest Data Structures

**Files:**
- Create: `src/seeknal/dag/manifest.py`
- Test: `src/tests/dag/test_manifest.py`

**Step 1: Write the failing test**

Create `src/tests/dag/test_manifest.py`:

```python
"""Tests for manifest data structures."""
import pytest
import json
from datetime import datetime
from seeknal.dag.manifest import (
    Manifest,
    Node,
    NodeType,
    Edge,
    ManifestMetadata,
)


class TestManifestMetadata:
    """Test ManifestMetadata class."""

    def test_metadata_creation(self):
        """Can create manifest metadata."""
        meta = ManifestMetadata(
            project="test_project",
            seeknal_version="2.0.0"
        )
        assert meta.project == "test_project"
        assert meta.seeknal_version == "2.0.0"
        assert meta.generated_at is not None

    def test_metadata_to_dict(self):
        """Metadata can be serialized to dict."""
        meta = ManifestMetadata(
            project="test_project",
            seeknal_version="2.0.0"
        )
        data = meta.to_dict()
        assert data["project"] == "test_project"
        assert "generated_at" in data


class TestNode:
    """Test Node class."""

    def test_node_creation(self):
        """Can create a node."""
        node = Node(
            id="feature_group.user_features",
            name="user_features",
            node_type=NodeType.FEATURE_GROUP,
            description="User features",
            owner="team@example.com",
            tags=["user", "features"],
        )
        assert node.id == "feature_group.user_features"
        assert node.node_type == NodeType.FEATURE_GROUP

    def test_node_with_columns(self):
        """Node can have column definitions."""
        node = Node(
            id="feature_group.user_features",
            name="user_features",
            node_type=NodeType.FEATURE_GROUP,
            columns={
                "user_id": "User identifier",
                "total_purchases": "Total purchase count"
            }
        )
        assert len(node.columns) == 2
        assert node.columns["user_id"] == "User identifier"

    def test_node_to_dict(self):
        """Node can be serialized to dict."""
        node = Node(
            id="source.traffic_day",
            name="traffic_day",
            node_type=NodeType.SOURCE,
        )
        data = node.to_dict()
        assert data["id"] == "source.traffic_day"
        assert data["type"] == "source"


class TestEdge:
    """Test Edge class."""

    def test_edge_creation(self):
        """Can create an edge."""
        edge = Edge(
            from_node="source.traffic_day",
            to_node="feature_group.user_features"
        )
        assert edge.from_node == "source.traffic_day"
        assert edge.to_node == "feature_group.user_features"


class TestManifest:
    """Test Manifest class."""

    def test_manifest_creation(self):
        """Can create an empty manifest."""
        manifest = Manifest(project="test_project")
        assert manifest.metadata.project == "test_project"
        assert len(manifest.nodes) == 0
        assert len(manifest.edges) == 0

    def test_add_node(self):
        """Can add nodes to manifest."""
        manifest = Manifest(project="test_project")

        node = Node(
            id="source.traffic_day",
            name="traffic_day",
            node_type=NodeType.SOURCE,
        )
        manifest.add_node(node)

        assert len(manifest.nodes) == 1
        assert "source.traffic_day" in manifest.nodes

    def test_add_edge(self):
        """Can add edges to manifest."""
        manifest = Manifest(project="test_project")

        manifest.add_edge("source.traffic_day", "feature_group.user_features")

        assert len(manifest.edges) == 1

    def test_get_node(self):
        """Can get a node by ID."""
        manifest = Manifest(project="test_project")
        node = Node(
            id="source.traffic_day",
            name="traffic_day",
            node_type=NodeType.SOURCE,
        )
        manifest.add_node(node)

        retrieved = manifest.get_node("source.traffic_day")
        assert retrieved.name == "traffic_day"

    def test_to_json(self):
        """Manifest can be serialized to JSON."""
        manifest = Manifest(project="test_project")
        manifest.add_node(Node(
            id="source.traffic_day",
            name="traffic_day",
            node_type=NodeType.SOURCE,
        ))
        manifest.add_edge("source.traffic_day", "feature_group.user_features")

        json_str = manifest.to_json()
        data = json.loads(json_str)

        assert data["metadata"]["project"] == "test_project"
        assert "source.traffic_day" in data["nodes"]
        assert len(data["edges"]) == 1

    def test_from_json(self):
        """Manifest can be deserialized from JSON."""
        json_data = {
            "metadata": {
                "project": "test_project",
                "seeknal_version": "2.0.0",
                "generated_at": "2026-01-08T10:00:00"
            },
            "nodes": {
                "source.traffic_day": {
                    "id": "source.traffic_day",
                    "name": "traffic_day",
                    "type": "source"
                }
            },
            "edges": [
                {"from": "source.traffic_day", "to": "feature_group.user"}
            ]
        }

        manifest = Manifest.from_dict(json_data)

        assert manifest.metadata.project == "test_project"
        assert len(manifest.nodes) == 1

    def test_get_upstream_nodes(self):
        """Can get upstream dependencies for a node."""
        manifest = Manifest(project="test_project")
        manifest.add_node(Node(id="source.a", name="a", node_type=NodeType.SOURCE))
        manifest.add_node(Node(id="source.b", name="b", node_type=NodeType.SOURCE))
        manifest.add_node(Node(id="fg.c", name="c", node_type=NodeType.FEATURE_GROUP))
        manifest.add_edge("source.a", "fg.c")
        manifest.add_edge("source.b", "fg.c")

        upstream = manifest.get_upstream_nodes("fg.c")
        assert len(upstream) == 2
        assert "source.a" in upstream
        assert "source.b" in upstream

    def test_get_downstream_nodes(self):
        """Can get downstream dependents for a node."""
        manifest = Manifest(project="test_project")
        manifest.add_node(Node(id="source.a", name="a", node_type=NodeType.SOURCE))
        manifest.add_node(Node(id="fg.b", name="b", node_type=NodeType.FEATURE_GROUP))
        manifest.add_node(Node(id="model.c", name="c", node_type=NodeType.MODEL))
        manifest.add_edge("source.a", "fg.b")
        manifest.add_edge("fg.b", "model.c")

        downstream = manifest.get_downstream_nodes("source.a")
        assert "fg.b" in downstream

    def test_detect_cycles(self):
        """Can detect cycles in the graph."""
        manifest = Manifest(project="test_project")
        manifest.add_node(Node(id="a", name="a", node_type=NodeType.SOURCE))
        manifest.add_node(Node(id="b", name="b", node_type=NodeType.FEATURE_GROUP))
        manifest.add_node(Node(id="c", name="c", node_type=NodeType.MODEL))
        manifest.add_edge("a", "b")
        manifest.add_edge("b", "c")
        manifest.add_edge("c", "a")  # Creates cycle

        has_cycle, cycle_path = manifest.detect_cycles()
        assert has_cycle is True
        assert len(cycle_path) > 0
```

**Step 2: Run test to verify it fails**

```bash
uv run pytest src/tests/dag/test_manifest.py -v
```

Expected: FAIL

**Step 3: Write minimal implementation**

Create `src/seeknal/dag/manifest.py`:

```python
"""
Manifest data structures for Seeknal 2.0.

The manifest is the serialized representation of the entire DAG,
including all nodes, edges, and metadata. It is generated by
`seeknal parse` and stored as manifest.json.
"""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple
import json


class NodeType(Enum):
    """Types of nodes in the DAG."""
    SOURCE = "source"
    TRANSFORM = "transform"
    FEATURE_GROUP = "feature_group"
    MODEL = "model"
    RULE = "rule"
    AGGREGATION = "aggregation"
    EXPOSURE = "exposure"


@dataclass
class ManifestMetadata:
    """Metadata about the manifest."""
    project: str
    seeknal_version: str = "2.0.0"
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "project": self.project,
            "seeknal_version": self.seeknal_version,
            "generated_at": self.generated_at,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ManifestMetadata":
        """Create from dictionary."""
        return cls(
            project=data["project"],
            seeknal_version=data.get("seeknal_version", "2.0.0"),
            generated_at=data.get("generated_at", datetime.now().isoformat()),
        )


@dataclass
class Node:
    """A node in the DAG."""
    id: str
    name: str
    node_type: NodeType
    description: Optional[str] = None
    owner: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    columns: Dict[str, str] = field(default_factory=dict)
    config: Dict[str, Any] = field(default_factory=dict)
    file_path: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "type": self.node_type.value,
            "description": self.description,
            "owner": self.owner,
            "tags": self.tags,
            "columns": self.columns,
            "config": self.config,
            "file_path": self.file_path,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Node":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            name=data["name"],
            node_type=NodeType(data["type"]),
            description=data.get("description"),
            owner=data.get("owner"),
            tags=data.get("tags", []),
            columns=data.get("columns", {}),
            config=data.get("config", {}),
            file_path=data.get("file_path"),
        )


@dataclass
class Edge:
    """An edge (dependency) in the DAG."""
    from_node: str
    to_node: str
    edge_type: str = "dependency"

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "from": self.from_node,
            "to": self.to_node,
            "type": self.edge_type,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Edge":
        """Create from dictionary."""
        return cls(
            from_node=data["from"],
            to_node=data["to"],
            edge_type=data.get("type", "dependency"),
        )


@dataclass
class Manifest:
    """
    The complete DAG manifest.

    Contains all nodes, edges, and metadata for the project.
    """
    metadata: ManifestMetadata = field(default_factory=lambda: ManifestMetadata(project=""))
    nodes: Dict[str, Node] = field(default_factory=dict)
    edges: List[Edge] = field(default_factory=list)

    def __init__(self, project: str = "", seeknal_version: str = "2.0.0"):
        self.metadata = ManifestMetadata(
            project=project,
            seeknal_version=seeknal_version,
        )
        self.nodes = {}
        self.edges = []
        self._upstream_cache: Dict[str, Set[str]] = {}
        self._downstream_cache: Dict[str, Set[str]] = {}

    def add_node(self, node: Node) -> None:
        """Add a node to the manifest."""
        self.nodes[node.id] = node
        self._clear_caches()

    def add_edge(self, from_node: str, to_node: str, edge_type: str = "dependency") -> None:
        """Add an edge to the manifest."""
        edge = Edge(from_node=from_node, to_node=to_node, edge_type=edge_type)
        self.edges.append(edge)
        self._clear_caches()

    def get_node(self, node_id: str) -> Optional[Node]:
        """Get a node by ID."""
        return self.nodes.get(node_id)

    def _clear_caches(self) -> None:
        """Clear computed caches."""
        self._upstream_cache = {}
        self._downstream_cache = {}

    def _build_adjacency_lists(self) -> Tuple[Dict[str, Set[str]], Dict[str, Set[str]]]:
        """Build upstream and downstream adjacency lists."""
        upstream: Dict[str, Set[str]] = {node_id: set() for node_id in self.nodes}
        downstream: Dict[str, Set[str]] = {node_id: set() for node_id in self.nodes}

        for edge in self.edges:
            if edge.to_node in upstream:
                upstream[edge.to_node].add(edge.from_node)
            if edge.from_node in downstream:
                downstream[edge.from_node].add(edge.to_node)

        return upstream, downstream

    def get_upstream_nodes(self, node_id: str) -> Set[str]:
        """Get immediate upstream dependencies."""
        if not self._upstream_cache:
            self._upstream_cache, self._downstream_cache = self._build_adjacency_lists()
        return self._upstream_cache.get(node_id, set())

    def get_downstream_nodes(self, node_id: str) -> Set[str]:
        """Get immediate downstream dependents."""
        if not self._downstream_cache:
            self._upstream_cache, self._downstream_cache = self._build_adjacency_lists()
        return self._downstream_cache.get(node_id, set())

    def detect_cycles(self) -> Tuple[bool, List[str]]:
        """
        Detect if there are cycles in the DAG.

        Returns:
            Tuple of (has_cycle, cycle_path)
        """
        visited = set()
        rec_stack = set()
        cycle_path = []

        def dfs(node: str, path: List[str]) -> bool:
            visited.add(node)
            rec_stack.add(node)
            path.append(node)

            for neighbor in self.get_downstream_nodes(node):
                if neighbor not in visited:
                    if dfs(neighbor, path):
                        return True
                elif neighbor in rec_stack:
                    # Found cycle
                    cycle_start = path.index(neighbor)
                    cycle_path.extend(path[cycle_start:])
                    cycle_path.append(neighbor)
                    return True

            path.pop()
            rec_stack.remove(node)
            return False

        for node_id in self.nodes:
            if node_id not in visited:
                if dfs(node_id, []):
                    return True, cycle_path

        return False, []

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "metadata": self.metadata.to_dict(),
            "nodes": {
                node_id: node.to_dict()
                for node_id, node in self.nodes.items()
            },
            "edges": [edge.to_dict() for edge in self.edges],
        }

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Manifest":
        """Create from dictionary."""
        manifest = cls.__new__(cls)
        manifest.metadata = ManifestMetadata.from_dict(data["metadata"])
        manifest.nodes = {
            node_id: Node.from_dict(node_data)
            for node_id, node_data in data.get("nodes", {}).items()
        }
        manifest.edges = [
            Edge.from_dict(edge_data)
            for edge_data in data.get("edges", [])
        ]
        manifest._upstream_cache = {}
        manifest._downstream_cache = {}
        return manifest

    @classmethod
    def from_json(cls, json_str: str) -> "Manifest":
        """Create from JSON string."""
        return cls.from_dict(json.loads(json_str))

    def save(self, path: str) -> None:
        """Save manifest to file."""
        with open(path, "w") as f:
            f.write(self.to_json())

    @classmethod
    def load(cls, path: str) -> "Manifest":
        """Load manifest from file."""
        with open(path, "r") as f:
            return cls.from_json(f.read())
```

Update `src/seeknal/dag/__init__.py`:

```python
"""DAG dependency tracking for Seeknal 2.0."""
from seeknal.dag.registry import DependencyRegistry, DependencyType, Dependency
from seeknal.dag.functions import (
    source,
    ref,
    use_transform,
    use_rule,
    SourceReference,
    NodeReference,
    RuleExpression,
)
from seeknal.dag.manifest import (
    Manifest,
    ManifestMetadata,
    Node,
    NodeType,
    Edge,
)

__all__ = [
    # Registry
    "DependencyRegistry",
    "DependencyType",
    "Dependency",
    # Functions
    "source",
    "ref",
    "use_transform",
    "use_rule",
    "SourceReference",
    "NodeReference",
    "RuleExpression",
    # Manifest
    "Manifest",
    "ManifestMetadata",
    "Node",
    "NodeType",
    "Edge",
]
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/dag/test_manifest.py -v
```

Expected: PASS (14 tests)

**Step 5: Commit**

```bash
git add src/seeknal/dag/ src/tests/dag/
git commit -m "feat(dag): add manifest data structures for DAG serialization

- Manifest class for complete DAG representation
- Node class with type, columns, metadata
- Edge class for dependencies
- Cycle detection for DAG validation
- JSON serialization/deserialization
- Upstream/downstream navigation"
```

---

## Task 4: Create Parse Command Foundation

**Files:**
- Create: `src/seeknal/dag/parser.py`
- Modify: `src/seeknal/cli/main.py`
- Test: `src/tests/dag/test_parser.py`

**Step 1: Write the failing test**

Create `src/tests/dag/test_parser.py`:

```python
"""Tests for the project parser."""
import pytest
import tempfile
import os
from pathlib import Path
from seeknal.dag.parser import ProjectParser
from seeknal.dag.manifest import Manifest, NodeType


class TestProjectParser:
    """Test the ProjectParser class."""

    def test_parser_creation(self):
        """Can create a parser."""
        parser = ProjectParser(project_name="test_project")
        assert parser.project_name == "test_project"

    def test_parse_empty_project(self):
        """Parser handles empty project."""
        parser = ProjectParser(project_name="test_project")
        manifest = parser.parse()

        assert manifest.metadata.project == "test_project"
        assert len(manifest.nodes) == 0

    def test_parse_creates_manifest(self):
        """Parsing creates a manifest."""
        parser = ProjectParser(project_name="test_project")
        manifest = parser.parse()

        assert isinstance(manifest, Manifest)

    def test_parser_discovers_sources_from_common_config(self):
        """Parser discovers sources from common config."""
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create common.yml with sources
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: traffic_day
    source: hive
    table: db.traffic
    description: Daily traffic data
""")
            parser = ProjectParser(
                project_name="test_project",
                project_path=tmpdir
            )
            manifest = parser.parse()

            assert "source.traffic_day" in manifest.nodes
            assert manifest.nodes["source.traffic_day"].node_type == NodeType.SOURCE

    def test_parser_discovers_transforms_from_common_config(self):
        """Parser discovers transforms from common config."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
transformations:
  - id: rename_cols
    className: RenameTransformer
    description: Rename columns
""")
            parser = ProjectParser(
                project_name="test_project",
                project_path=tmpdir
            )
            manifest = parser.parse()

            assert "transform.rename_cols" in manifest.nodes

    def test_parser_discovers_rules_from_common_config(self):
        """Parser discovers rules from common config."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
rules:
  - id: callExpression
    rule:
      value: "service_type = 'Voice'"
""")
            parser = ProjectParser(
                project_name="test_project",
                project_path=tmpdir
            )
            manifest = parser.parse()

            assert "rule.callExpression" in manifest.nodes

    def test_parser_validates_references(self):
        """Parser validates that all references exist."""
        parser = ProjectParser(project_name="test_project")

        # Add a node that references a non-existent source
        parser._pending_references = [
            ("feature_group.test", "source.missing", "ref")
        ]

        errors = parser.validate()
        assert len(errors) > 0
        assert "source.missing" in errors[0]
```

**Step 2: Run test to verify it fails**

```bash
uv run pytest src/tests/dag/test_parser.py -v
```

Expected: FAIL

**Step 3: Write minimal implementation**

Create `src/seeknal/dag/parser.py`:

```python
"""
Project parser for Seeknal 2.0.

Parses the project structure, common config, and Python files
to build the complete DAG manifest.
"""
import os
import yaml
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from seeknal.dag.manifest import Manifest, Node, NodeType, Edge


class ProjectParser:
    """
    Parses a Seeknal project to build the DAG manifest.

    The parser:
    1. Reads common.yml for sources, transforms, rules
    2. Discovers Python files for feature groups, models
    3. Validates all references
    4. Builds the complete manifest
    """

    def __init__(
        self,
        project_name: str,
        project_path: Optional[str] = None,
        seeknal_version: str = "2.0.0"
    ):
        self.project_name = project_name
        self.project_path = Path(project_path) if project_path else Path.cwd()
        self.seeknal_version = seeknal_version
        self.manifest = Manifest(
            project=project_name,
            seeknal_version=seeknal_version
        )
        self._pending_references: List[Tuple[str, str, str]] = []
        self._errors: List[str] = []
        self._warnings: List[str] = []

    def parse(self) -> Manifest:
        """
        Parse the project and return the manifest.

        Returns:
            The built Manifest
        """
        # Parse common config
        self._parse_common_config()

        # TODO: Parse Python files for feature groups, models
        # self._parse_python_files()

        # Build edges from registry
        # self._build_edges_from_registry()

        return self.manifest

    def _parse_common_config(self) -> None:
        """Parse common.yml for sources, transforms, rules."""
        common_path = self.project_path / "common.yml"
        if not common_path.exists():
            return

        with open(common_path, "r") as f:
            config = yaml.safe_load(f) or {}

        # Parse sources
        for source_config in config.get("sources", []):
            node = Node(
                id=f"source.{source_config['id']}",
                name=source_config["id"],
                node_type=NodeType.SOURCE,
                description=source_config.get("description"),
                config={
                    "source": source_config.get("source"),
                    "table": source_config.get("table"),
                    "params": source_config.get("params", {}),
                }
            )
            self.manifest.add_node(node)

        # Parse transformations
        for transform_config in config.get("transformations", []):
            node = Node(
                id=f"transform.{transform_config['id']}",
                name=transform_config["id"],
                node_type=NodeType.TRANSFORM,
                description=transform_config.get("description"),
                config={
                    "className": transform_config.get("className"),
                    "params": transform_config.get("params", {}),
                }
            )
            self.manifest.add_node(node)

        # Parse rules
        for rule_config in config.get("rules", []):
            node = Node(
                id=f"rule.{rule_config['id']}",
                name=rule_config["id"],
                node_type=NodeType.RULE,
                description=rule_config.get("description"),
                config={
                    "rule": rule_config.get("rule", {}),
                }
            )
            self.manifest.add_node(node)

        # Parse aggregations (if present)
        for agg_config in config.get("aggregations", []):
            node = Node(
                id=f"aggregation.{agg_config['id']}",
                name=agg_config["id"],
                node_type=NodeType.AGGREGATION,
                description=agg_config.get("description"),
                config=agg_config,
            )
            self.manifest.add_node(node)

    def validate(self) -> List[str]:
        """
        Validate the parsed manifest.

        Returns:
            List of validation errors
        """
        errors = []

        # Check for missing references
        for node_id, ref_id, ref_type in self._pending_references:
            if ref_id not in self.manifest.nodes:
                errors.append(
                    f"Node '{node_id}' references '{ref_id}' which does not exist"
                )

        # Check for cycles
        has_cycle, cycle_path = self.manifest.detect_cycles()
        if has_cycle:
            errors.append(f"Cycle detected in DAG: {' -> '.join(cycle_path)}")

        return errors

    def get_warnings(self) -> List[str]:
        """Get parsing warnings."""
        return self._warnings.copy()

    def get_errors(self) -> List[str]:
        """Get parsing errors."""
        return self._errors.copy()
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/dag/test_parser.py -v
```

Expected: PASS (7 tests)

**Step 5: Commit**

```bash
git add src/seeknal/dag/ src/tests/dag/
git commit -m "feat(dag): add project parser for common.yml

- ProjectParser class to build manifest from project
- Parse sources, transforms, rules from common.yml
- Validation for missing references
- Foundation for Python file discovery"
```

---

## Task 5: Add `seeknal parse` CLI Command

**Files:**
- Modify: `src/seeknal/cli/main.py`
- Test: `src/tests/cli/test_parse_command.py`

**Step 1: Write the failing test**

Create `src/tests/cli/test_parse_command.py`:

```python
"""Tests for the parse CLI command."""
import pytest
import tempfile
import os
from pathlib import Path
from typer.testing import CliRunner
from seeknal.cli.main import app


runner = CliRunner()


class TestParseCommand:
    """Test the parse command."""

    def test_parse_command_exists(self):
        """Parse command should exist."""
        result = runner.invoke(app, ["parse", "--help"])
        assert result.exit_code == 0
        assert "Parse" in result.stdout or "parse" in result.stdout

    def test_parse_empty_project(self):
        """Parse handles project with no common.yml."""
        with tempfile.TemporaryDirectory() as tmpdir:
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])
            # Should succeed but report 0 nodes
            assert "0" in result.stdout or "nodes" in result.stdout.lower()

    def test_parse_with_common_config(self):
        """Parse discovers nodes from common.yml."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: traffic_day
    source: hive
    table: db.traffic
transformations:
  - id: rename_cols
    className: RenameTransformer
rules:
  - id: callExpression
    rule:
      value: "service = 'Voice'"
""")
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])

            assert result.exit_code == 0
            assert "3" in result.stdout  # 3 nodes

    def test_parse_writes_manifest(self):
        """Parse writes manifest.json to target directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: test_source
    source: hive
    table: db.test
""")
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])

            manifest_path = Path(tmpdir) / "target" / "manifest.json"
            assert manifest_path.exists()

    def test_parse_shows_validation_errors(self):
        """Parse shows validation errors."""
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create invalid config (would need actual invalid structure)
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])
            # Should complete without crash
            assert result.exit_code == 0
```

**Step 2: Run test to verify it fails**

```bash
mkdir -p src/tests/cli
touch src/tests/cli/__init__.py
uv run pytest src/tests/cli/test_parse_command.py -v
```

Expected: FAIL (parse command doesn't exist)

**Step 3: Write minimal implementation**

Add to `src/seeknal/cli/main.py` (after existing imports):

```python
# Add these imports at the top
from seeknal.dag.parser import ProjectParser
from seeknal.dag.manifest import Manifest
import json

# Add this command after the existing commands

@app.command()
def parse(
    project_path: str = typer.Option(
        ".",
        "--project-path",
        "-p",
        help="Path to the project directory"
    ),
    project_name: str = typer.Option(
        None,
        "--project-name",
        "-n",
        help="Name of the project (defaults to directory name)"
    ),
    output_format: OutputFormat = typer.Option(
        OutputFormat.TABLE,
        "--format",
        "-f",
        help="Output format"
    ),
):
    """
    Parse the project and build the DAG manifest.

    Discovers all nodes (sources, transforms, feature groups, models)
    and their dependencies. Generates manifest.json in the target directory.

    Examples:
        seeknal parse
        seeknal parse --project-path ./my_project
        seeknal parse --format json
    """
    from pathlib import Path

    project_path_obj = Path(project_path).resolve()

    if project_name is None:
        project_name = project_path_obj.name

    _echo_info(f"Parsing project '{project_name}'...")

    # Parse the project
    parser = ProjectParser(
        project_name=project_name,
        project_path=str(project_path_obj)
    )
    manifest = parser.parse()

    # Validate
    errors = parser.validate()
    warnings = parser.get_warnings()

    # Count nodes by type
    node_counts = {}
    for node in manifest.nodes.values():
        node_type = node.node_type.value
        node_counts[node_type] = node_counts.get(node_type, 0) + 1

    # Create target directory and write manifest
    target_dir = project_path_obj / "target"
    target_dir.mkdir(exist_ok=True)
    manifest_path = target_dir / "manifest.json"
    manifest.save(str(manifest_path))

    # Display results
    total_nodes = len(manifest.nodes)
    total_edges = len(manifest.edges)

    if output_format == OutputFormat.JSON:
        result = {
            "project": project_name,
            "nodes": total_nodes,
            "edges": total_edges,
            "node_counts": node_counts,
            "errors": errors,
            "warnings": warnings,
            "manifest_path": str(manifest_path),
        }
        typer.echo(json.dumps(result, indent=2))
    else:
        typer.echo()

        # Node counts
        if node_counts:
            for node_type, count in sorted(node_counts.items()):
                typer.echo(f"  {node_type.capitalize()}s: {count}")
            typer.echo(f"  {'' * 30}")

        typer.echo(f"  Total: {total_nodes} nodes, {total_edges} edges")
        typer.echo()

        # Manifest path
        _echo_success(f" Manifest written to {manifest_path}")

        # Validation results
        if errors:
            typer.echo()
            _echo_error("Validation errors:")
            for error in errors:
                typer.echo(f"   {error}")
        else:
            _echo_success(" DAG validated: no issues detected")

        # Warnings
        if warnings:
            typer.echo()
            _echo_info("Warnings:")
            for warning in warnings:
                typer.echo(f"   {warning}")
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/cli/test_parse_command.py -v
```

Expected: PASS (5 tests)

**Step 5: Commit**

```bash
git add src/seeknal/cli/main.py src/tests/cli/
git commit -m "feat(cli): add seeknal parse command

- Parse project to build DAG manifest
- Discover nodes from common.yml
- Write manifest.json to target/
- Display node counts and validation results
- Support JSON output format"
```

---

## Task 6: Add Manifest Diff Detection

**Files:**
- Create: `src/seeknal/dag/diff.py`
- Test: `src/tests/dag/test_diff.py`

**Step 1: Write the failing test**

Create `src/tests/dag/test_diff.py`:

```python
"""Tests for manifest diff detection."""
import pytest
from seeknal.dag.manifest import Manifest, Node, NodeType
from seeknal.dag.diff import ManifestDiff, DiffType, NodeDiff


class TestManifestDiff:
    """Test manifest diff detection."""

    def test_detect_added_node(self):
        """Detect newly added nodes."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        new.add_node(Node(
            id="source.new_source",
            name="new_source",
            node_type=NodeType.SOURCE
        ))

        diff = ManifestDiff.compare(old, new)

        assert len(diff.added) == 1
        assert diff.added[0].node_id == "source.new_source"

    def test_detect_removed_node(self):
        """Detect removed nodes."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        old.add_node(Node(
            id="source.old_source",
            name="old_source",
            node_type=NodeType.SOURCE
        ))

        diff = ManifestDiff.compare(old, new)

        assert len(diff.removed) == 1
        assert diff.removed[0].node_id == "source.old_source"

    def test_detect_modified_node_columns(self):
        """Detect modified node columns."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        old.add_node(Node(
            id="fg.features",
            name="features",
            node_type=NodeType.FEATURE_GROUP,
            columns={"col1": "desc1", "col2": "desc2"}
        ))

        new.add_node(Node(
            id="fg.features",
            name="features",
            node_type=NodeType.FEATURE_GROUP,
            columns={"col1": "desc1", "col2": "desc2", "col3": "desc3"}
        ))

        diff = ManifestDiff.compare(old, new)

        assert len(diff.modified) == 1
        assert "col3" in str(diff.modified[0].changes)

    def test_detect_added_edge(self):
        """Detect newly added edges."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        # Add same nodes to both
        for m in [old, new]:
            m.add_node(Node(id="a", name="a", node_type=NodeType.SOURCE))
            m.add_node(Node(id="b", name="b", node_type=NodeType.FEATURE_GROUP))

        # Add edge only to new
        new.add_edge("a", "b")

        diff = ManifestDiff.compare(old, new)

        assert len(diff.added_edges) == 1

    def test_no_changes(self):
        """No changes when manifests are identical."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        for m in [old, new]:
            m.add_node(Node(id="a", name="a", node_type=NodeType.SOURCE))

        diff = ManifestDiff.compare(old, new)

        assert diff.has_changes() is False

    def test_diff_summary(self):
        """Can generate diff summary."""
        old = Manifest(project="test")
        new = Manifest(project="test")

        new.add_node(Node(id="a", name="a", node_type=NodeType.SOURCE))

        diff = ManifestDiff.compare(old, new)
        summary = diff.summary()

        assert "ADDED" in summary
        assert "a" in summary
```

**Step 2: Run test to verify it fails**

```bash
uv run pytest src/tests/dag/test_diff.py -v
```

Expected: FAIL

**Step 3: Write minimal implementation**

Create `src/seeknal/dag/diff.py`:

```python
"""
Manifest diff detection for Seeknal 2.0.

Compares two manifests and reports changes (added, removed, modified nodes/edges).
"""
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Set

from seeknal.dag.manifest import Manifest, Node, Edge


class DiffType(Enum):
    """Type of diff."""
    ADDED = "added"
    REMOVED = "removed"
    MODIFIED = "modified"


@dataclass
class NodeDiff:
    """Represents a change to a node."""
    node_id: str
    diff_type: DiffType
    old_node: Optional[Node] = None
    new_node: Optional[Node] = None
    changes: Dict[str, Any] = field(default_factory=dict)


@dataclass
class EdgeDiff:
    """Represents a change to an edge."""
    from_node: str
    to_node: str
    diff_type: DiffType


@dataclass
class ManifestDiff:
    """
    Represents the difference between two manifests.
    """
    added: List[NodeDiff] = field(default_factory=list)
    removed: List[NodeDiff] = field(default_factory=list)
    modified: List[NodeDiff] = field(default_factory=list)
    added_edges: List[EdgeDiff] = field(default_factory=list)
    removed_edges: List[EdgeDiff] = field(default_factory=list)

    def has_changes(self) -> bool:
        """Check if there are any changes."""
        return bool(
            self.added or
            self.removed or
            self.modified or
            self.added_edges or
            self.removed_edges
        )

    def summary(self) -> str:
        """Generate a human-readable summary of changes."""
        lines = []

        if self.added:
            lines.append("")
            lines.append("+ ADDED ({} nodes)".format(len(self.added)))
            for diff in self.added:
                lines.append(f"  + {diff.node_id}")

        if self.removed:
            lines.append("")
            lines.append("- REMOVED ({} nodes)".format(len(self.removed)))
            for diff in self.removed:
                lines.append(f"  - {diff.node_id}")

        if self.modified:
            lines.append("")
            lines.append("~ MODIFIED ({} nodes)".format(len(self.modified)))
            for diff in self.modified:
                lines.append(f"  ~ {diff.node_id}")
                for key, change in diff.changes.items():
                    if isinstance(change, dict):
                        if "added" in change:
                            for item in change["added"]:
                                lines.append(f"    + {key}: {item}")
                        if "removed" in change:
                            for item in change["removed"]:
                                lines.append(f"    - {key}: {item}")
                    else:
                        lines.append(f"    {key}: {change}")

        if self.added_edges:
            lines.append("")
            lines.append(" NEW DEPENDENCIES ({})".format(len(self.added_edges)))
            for edge in self.added_edges:
                lines.append(f"  + {edge.from_node}  {edge.to_node}")

        if self.removed_edges:
            lines.append("")
            lines.append(" REMOVED DEPENDENCIES ({})".format(len(self.removed_edges)))
            for edge in self.removed_edges:
                lines.append(f"  - {edge.from_node}  {edge.to_node}")

        if not lines:
            return "No changes detected"

        return "\n".join(lines)

    @classmethod
    def compare(cls, old: Manifest, new: Manifest) -> "ManifestDiff":
        """
        Compare two manifests and return the diff.

        Args:
            old: The previous manifest
            new: The new manifest

        Returns:
            ManifestDiff with all detected changes
        """
        diff = cls()

        old_node_ids = set(old.nodes.keys())
        new_node_ids = set(new.nodes.keys())

        # Find added nodes
        for node_id in new_node_ids - old_node_ids:
            diff.added.append(NodeDiff(
                node_id=node_id,
                diff_type=DiffType.ADDED,
                new_node=new.nodes[node_id]
            ))

        # Find removed nodes
        for node_id in old_node_ids - new_node_ids:
            diff.removed.append(NodeDiff(
                node_id=node_id,
                diff_type=DiffType.REMOVED,
                old_node=old.nodes[node_id]
            ))

        # Find modified nodes
        for node_id in old_node_ids & new_node_ids:
            old_node = old.nodes[node_id]
            new_node = new.nodes[node_id]
            changes = cls._compare_nodes(old_node, new_node)

            if changes:
                diff.modified.append(NodeDiff(
                    node_id=node_id,
                    diff_type=DiffType.MODIFIED,
                    old_node=old_node,
                    new_node=new_node,
                    changes=changes
                ))

        # Compare edges
        old_edges = {(e.from_node, e.to_node) for e in old.edges}
        new_edges = {(e.from_node, e.to_node) for e in new.edges}

        for from_node, to_node in new_edges - old_edges:
            diff.added_edges.append(EdgeDiff(
                from_node=from_node,
                to_node=to_node,
                diff_type=DiffType.ADDED
            ))

        for from_node, to_node in old_edges - new_edges:
            diff.removed_edges.append(EdgeDiff(
                from_node=from_node,
                to_node=to_node,
                diff_type=DiffType.REMOVED
            ))

        return diff

    @staticmethod
    def _compare_nodes(old: Node, new: Node) -> Dict[str, Any]:
        """Compare two nodes and return changes."""
        changes = {}

        # Compare columns
        old_cols = set(old.columns.keys())
        new_cols = set(new.columns.keys())

        added_cols = new_cols - old_cols
        removed_cols = old_cols - new_cols

        if added_cols or removed_cols:
            changes["columns"] = {
                "added": list(added_cols),
                "removed": list(removed_cols)
            }

        # Compare tags
        if set(old.tags) != set(new.tags):
            changes["tags"] = {
                "added": list(set(new.tags) - set(old.tags)),
                "removed": list(set(old.tags) - set(new.tags))
            }

        # Compare description
        if old.description != new.description:
            changes["description"] = {
                "old": old.description,
                "new": new.description
            }

        # Compare owner
        if old.owner != new.owner:
            changes["owner"] = {
                "old": old.owner,
                "new": new.owner
            }

        return changes
```

Update `src/seeknal/dag/__init__.py` to export diff classes:

```python
"""DAG dependency tracking for Seeknal 2.0."""
from seeknal.dag.registry import DependencyRegistry, DependencyType, Dependency
from seeknal.dag.functions import (
    source,
    ref,
    use_transform,
    use_rule,
    SourceReference,
    NodeReference,
    RuleExpression,
)
from seeknal.dag.manifest import (
    Manifest,
    ManifestMetadata,
    Node,
    NodeType,
    Edge,
)
from seeknal.dag.diff import (
    ManifestDiff,
    NodeDiff,
    EdgeDiff,
    DiffType,
)

__all__ = [
    # Registry
    "DependencyRegistry",
    "DependencyType",
    "Dependency",
    # Functions
    "source",
    "ref",
    "use_transform",
    "use_rule",
    "SourceReference",
    "NodeReference",
    "RuleExpression",
    # Manifest
    "Manifest",
    "ManifestMetadata",
    "Node",
    "NodeType",
    "Edge",
    # Diff
    "ManifestDiff",
    "NodeDiff",
    "EdgeDiff",
    "DiffType",
]
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/dag/test_diff.py -v
```

Expected: PASS (6 tests)

**Step 5: Commit**

```bash
git add src/seeknal/dag/ src/tests/dag/
git commit -m "feat(dag): add manifest diff detection

- ManifestDiff class compares two manifests
- Detect added, removed, modified nodes
- Detect added/removed edges
- Generate human-readable diff summary
- Git-style diff output format"
```

---

## Task 7: Integrate Diff into Parse Command

**Files:**
- Modify: `src/seeknal/cli/main.py`
- Test: `src/tests/cli/test_parse_diff.py`

**Step 1: Write the failing test**

Create `src/tests/cli/test_parse_diff.py`:

```python
"""Tests for parse command diff display."""
import pytest
import tempfile
import json
from pathlib import Path
from typer.testing import CliRunner
from seeknal.cli.main import app


runner = CliRunner()


class TestParseDiff:
    """Test parse command diff functionality."""

    def test_parse_shows_diff_when_manifest_exists(self):
        """Parse shows diff when previous manifest exists."""
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create initial common.yml
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: source_a
    source: hive
    table: db.a
""")
            # First parse
            runner.invoke(app, ["parse", "--project-path", tmpdir])

            # Add another source
            common_yml.write_text("""
sources:
  - id: source_a
    source: hive
    table: db.a
  - id: source_b
    source: hive
    table: db.b
""")
            # Second parse
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])

            assert "ADDED" in result.stdout or "added" in result.stdout.lower()
            assert "source_b" in result.stdout

    def test_parse_shows_no_changes_message(self):
        """Parse shows 'no changes' when manifest unchanged."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: source_a
    source: hive
    table: db.a
""")
            # First parse
            runner.invoke(app, ["parse", "--project-path", tmpdir])

            # Second parse (no changes)
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])

            # Should indicate no changes or just show node count
            assert result.exit_code == 0

    def test_parse_detects_removed_nodes(self):
        """Parse detects when nodes are removed."""
        with tempfile.TemporaryDirectory() as tmpdir:
            common_yml = Path(tmpdir) / "common.yml"
            common_yml.write_text("""
sources:
  - id: source_a
    source: hive
    table: db.a
  - id: source_b
    source: hive
    table: db.b
""")
            # First parse
            runner.invoke(app, ["parse", "--project-path", tmpdir])

            # Remove source_b
            common_yml.write_text("""
sources:
  - id: source_a
    source: hive
    table: db.a
""")
            # Second parse
            result = runner.invoke(app, ["parse", "--project-path", tmpdir])

            assert "REMOVED" in result.stdout or "removed" in result.stdout.lower()
```

**Step 2: Run test to verify it fails**

```bash
uv run pytest src/tests/cli/test_parse_diff.py -v
```

Expected: FAIL (diff not shown)

**Step 3: Update parse command to show diff**

Update the `parse` command in `src/seeknal/cli/main.py`:

```python
@app.command()
def parse(
    project_path: str = typer.Option(
        ".",
        "--project-path",
        "-p",
        help="Path to the project directory"
    ),
    project_name: str = typer.Option(
        None,
        "--project-name",
        "-n",
        help="Name of the project (defaults to directory name)"
    ),
    output_format: OutputFormat = typer.Option(
        OutputFormat.TABLE,
        "--format",
        "-f",
        help="Output format"
    ),
):
    """
    Parse the project and build the DAG manifest.

    Discovers all nodes (sources, transforms, feature groups, models)
    and their dependencies. Generates manifest.json in the target directory.
    Shows diff from previous manifest if it exists.

    Examples:
        seeknal parse
        seeknal parse --project-path ./my_project
        seeknal parse --format json
    """
    from pathlib import Path
    from seeknal.dag.parser import ProjectParser
    from seeknal.dag.manifest import Manifest
    from seeknal.dag.diff import ManifestDiff

    project_path_obj = Path(project_path).resolve()

    if project_name is None:
        project_name = project_path_obj.name

    _echo_info(f"Parsing project '{project_name}'...")

    # Load previous manifest if exists
    target_dir = project_path_obj / "target"
    manifest_path = target_dir / "manifest.json"
    prev_manifest_path = target_dir / "manifest.prev.json"

    old_manifest = None
    if manifest_path.exists():
        try:
            old_manifest = Manifest.load(str(manifest_path))
        except Exception:
            pass

    # Parse the project
    parser = ProjectParser(
        project_name=project_name,
        project_path=str(project_path_obj)
    )
    manifest = parser.parse()

    # Validate
    errors = parser.validate()
    warnings = parser.get_warnings()

    # Count nodes by type
    node_counts = {}
    for node in manifest.nodes.values():
        node_type = node.node_type.value
        node_counts[node_type] = node_counts.get(node_type, 0) + 1

    # Create target directory
    target_dir.mkdir(exist_ok=True)

    # Backup previous manifest
    if manifest_path.exists():
        import shutil
        shutil.copy(manifest_path, prev_manifest_path)

    # Write new manifest
    manifest.save(str(manifest_path))

    # Compute diff if we have old manifest
    diff = None
    if old_manifest:
        diff = ManifestDiff.compare(old_manifest, manifest)

    # Display results
    total_nodes = len(manifest.nodes)
    total_edges = len(manifest.edges)

    if output_format == OutputFormat.JSON:
        result = {
            "project": project_name,
            "nodes": total_nodes,
            "edges": total_edges,
            "node_counts": node_counts,
            "errors": errors,
            "warnings": warnings,
            "manifest_path": str(manifest_path),
        }
        if diff and diff.has_changes():
            result["changes"] = {
                "added": [d.node_id for d in diff.added],
                "removed": [d.node_id for d in diff.removed],
                "modified": [d.node_id for d in diff.modified],
            }
        typer.echo(json.dumps(result, indent=2))
    else:
        typer.echo()

        # Node counts
        if node_counts:
            for node_type, count in sorted(node_counts.items()):
                typer.echo(f"  {node_type.capitalize()}s: {count}")
            typer.echo(f"  {'' * 30}")

        typer.echo(f"  Total: {total_nodes} nodes, {total_edges} edges")
        typer.echo()

        # Manifest path
        _echo_success(f" Manifest written to {manifest_path}")

        # Show diff if changes detected
        if diff and diff.has_changes():
            typer.echo()
            typer.echo("" * 60)
            typer.echo("                    CHANGES DETECTED")
            typer.echo("" * 60)
            typer.echo(diff.summary())
            typer.echo()
        elif old_manifest:
            _echo_info("No changes from previous manifest")

        # Validation results
        if errors:
            typer.echo()
            _echo_error("Validation errors:")
            for error in errors:
                typer.echo(f"   {error}")
        else:
            _echo_success(" DAG validated: no issues detected")

        # Warnings
        if warnings:
            typer.echo()
            _echo_info("Warnings:")
            for warning in warnings:
                typer.echo(f"   {warning}")
```

**Step 4: Run test to verify it passes**

```bash
uv run pytest src/tests/cli/test_parse_diff.py -v
```

Expected: PASS (3 tests)

**Step 5: Commit**

```bash
git add src/seeknal/cli/main.py src/tests/cli/
git commit -m "feat(cli): add diff display to parse command

- Show changes when previous manifest exists
- Display added, removed, modified nodes
- Backup previous manifest as manifest.prev.json
- Git-style diff output in terminal"
```

---

## Summary: Phase 1 Foundation Complete

After completing Tasks 1-7, you will have:

1. **Dependency Registry** (`src/seeknal/dag/registry.py`)
   - Singleton pattern for tracking dependencies
   - Thread-safe implementation

2. **Core Functions** (`src/seeknal/dag/functions.py`)
   - `source()` - Data source dependencies
   - `ref()` - Node references
   - `use_transform()` - Reusable transformations
   - `use_rule()` - Business rules

3. **Manifest System** (`src/seeknal/dag/manifest.py`)
   - Node and Edge data structures
   - JSON serialization
   - Cycle detection
   - Upstream/downstream navigation

4. **Project Parser** (`src/seeknal/dag/parser.py`)
   - Parse common.yml
   - Build manifest from project

5. **Diff Detection** (`src/seeknal/dag/diff.py`)
   - Compare manifests
   - Track added/removed/modified nodes

6. **CLI Command** (`src/seeknal/cli/main.py`)
   - `seeknal parse` with diff display

---

## Next Steps (Tasks 8-12)

After Phase 1, continue with:

- **Task 8:** Add `use_aggregation()` function
- **Task 9:** Implement selection syntax for `seeknal run`
- **Task 10:** Add `seeknal lineage` command
- **Task 11:** Add `seeknal impact` command
- **Task 12:** Add `seeknal search` command

These will be documented in a follow-up implementation plan.

---

*Plan created: 2026-01-08*
*Worktree: `.worktrees/seeknal-2.0-foundation`*
*Branch: `feature/seeknal-2.0-foundation`*
