"""
Manifest data structures for Seeknal 2.0.

The manifest is the serialized representation of the entire DAG,
including all nodes, edges, and metadata. It is generated by
`seeknal parse` and stored as manifest.json.
"""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Tuple
import json


class NodeType(Enum):
    """Types of nodes in the DAG."""
    SOURCE = "source"
    TRANSFORM = "transform"
    FEATURE_GROUP = "feature_group"
    MODEL = "model"
    RULE = "rule"
    AGGREGATION = "aggregation"
    EXPOSURE = "exposure"


@dataclass
class ManifestMetadata:
    """Metadata about the manifest."""
    project: str
    seeknal_version: str = "2.0.0"
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "project": self.project,
            "seeknal_version": self.seeknal_version,
            "generated_at": self.generated_at,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ManifestMetadata":
        """Create from dictionary."""
        return cls(
            project=data["project"],
            seeknal_version=data.get("seeknal_version", "2.0.0"),
            generated_at=data.get("generated_at", datetime.now().isoformat()),
        )


@dataclass
class Node:
    """A node in the DAG."""
    id: str
    name: str
    node_type: NodeType
    description: Optional[str] = None
    owner: Optional[str] = None
    tags: List[str] = field(default_factory=list)
    columns: Dict[str, str] = field(default_factory=dict)
    config: Dict[str, Any] = field(default_factory=dict)
    file_path: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "type": self.node_type.value,
            "description": self.description,
            "owner": self.owner,
            "tags": self.tags,
            "columns": self.columns,
            "config": self.config,
            "file_path": self.file_path,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Node":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            name=data["name"],
            node_type=NodeType(data["type"]),
            description=data.get("description"),
            owner=data.get("owner"),
            tags=data.get("tags", []),
            columns=data.get("columns", {}),
            config=data.get("config", {}),
            file_path=data.get("file_path"),
        )


@dataclass
class Edge:
    """An edge (dependency) in the DAG."""
    from_node: str
    to_node: str
    edge_type: str = "dependency"

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "from": self.from_node,
            "to": self.to_node,
            "type": self.edge_type,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Edge":
        """Create from dictionary."""
        return cls(
            from_node=data["from"],
            to_node=data["to"],
            edge_type=data.get("type", "dependency"),
        )


@dataclass
class Manifest:
    """
    The complete DAG manifest.

    Contains all nodes, edges, and metadata for the project.
    """
    metadata: ManifestMetadata = field(default_factory=lambda: ManifestMetadata(project=""))
    nodes: Dict[str, Node] = field(default_factory=dict)
    edges: List[Edge] = field(default_factory=list)

    def __init__(self, project: str = "", seeknal_version: str = "2.0.0"):
        self.metadata = ManifestMetadata(
            project=project,
            seeknal_version=seeknal_version,
        )
        self.nodes = {}
        self.edges = []
        self._upstream_cache: Dict[str, Set[str]] = {}
        self._downstream_cache: Dict[str, Set[str]] = {}

    def add_node(self, node: Node) -> None:
        """Add a node to the manifest."""
        self.nodes[node.id] = node
        self._clear_caches()

    def add_edge(self, from_node: str, to_node: str, edge_type: str = "dependency") -> None:
        """Add an edge to the manifest."""
        edge = Edge(from_node=from_node, to_node=to_node, edge_type=edge_type)
        self.edges.append(edge)
        self._clear_caches()

    def get_node(self, node_id: str) -> Optional[Node]:
        """Get a node by ID."""
        return self.nodes.get(node_id)

    def _clear_caches(self) -> None:
        """Clear computed caches."""
        self._upstream_cache = {}
        self._downstream_cache = {}

    def _build_adjacency_lists(self) -> Tuple[Dict[str, Set[str]], Dict[str, Set[str]]]:
        """Build upstream and downstream adjacency lists."""
        upstream: Dict[str, Set[str]] = {node_id: set() for node_id in self.nodes}
        downstream: Dict[str, Set[str]] = {node_id: set() for node_id in self.nodes}

        for edge in self.edges:
            if edge.to_node in upstream:
                upstream[edge.to_node].add(edge.from_node)
            if edge.from_node in downstream:
                downstream[edge.from_node].add(edge.to_node)

        return upstream, downstream

    def get_upstream_nodes(self, node_id: str) -> Set[str]:
        """Get immediate upstream dependencies."""
        if not self._upstream_cache:
            self._upstream_cache, self._downstream_cache = self._build_adjacency_lists()
        return self._upstream_cache.get(node_id, set())

    def get_downstream_nodes(self, node_id: str) -> Set[str]:
        """Get immediate downstream dependents."""
        if not self._downstream_cache:
            self._upstream_cache, self._downstream_cache = self._build_adjacency_lists()
        return self._downstream_cache.get(node_id, set())

    def detect_cycles(self) -> Tuple[bool, List[str]]:
        """
        Detect if there are cycles in the DAG.

        Returns:
            Tuple of (has_cycle, cycle_path)
        """
        visited = set()
        rec_stack = set()
        cycle_path = []

        def dfs(node: str, path: List[str]) -> bool:
            visited.add(node)
            rec_stack.add(node)
            path.append(node)

            for neighbor in self.get_downstream_nodes(node):
                if neighbor not in visited:
                    if dfs(neighbor, path):
                        return True
                elif neighbor in rec_stack:
                    # Found cycle
                    cycle_start = path.index(neighbor)
                    cycle_path.extend(path[cycle_start:])
                    cycle_path.append(neighbor)
                    return True

            path.pop()
            rec_stack.remove(node)
            return False

        for node_id in self.nodes:
            if node_id not in visited:
                if dfs(node_id, []):
                    return True, cycle_path

        return False, []

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "metadata": self.metadata.to_dict(),
            "nodes": {
                node_id: node.to_dict()
                for node_id, node in self.nodes.items()
            },
            "edges": [edge.to_dict() for edge in self.edges],
        }

    def to_json(self, indent: int = 2) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=indent)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Manifest":
        """Create from dictionary."""
        manifest = cls.__new__(cls)
        manifest.metadata = ManifestMetadata.from_dict(data["metadata"])
        manifest.nodes = {
            node_id: Node.from_dict(node_data)
            for node_id, node_data in data.get("nodes", {}).items()
        }
        manifest.edges = [
            Edge.from_dict(edge_data)
            for edge_data in data.get("edges", [])
        ]
        manifest._upstream_cache = {}
        manifest._downstream_cache = {}
        return manifest

    @classmethod
    def from_json(cls, json_str: str) -> "Manifest":
        """Create from JSON string."""
        return cls.from_dict(json.loads(json_str))

    def save(self, path: str) -> None:
        """Save manifest to file."""
        with open(path, "w") as f:
            f.write(self.to_json())

    @classmethod
    def load(cls, path: str) -> "Manifest":
        """Load manifest from file."""
        with open(path, "r") as f:
            return cls.from_json(f.read())
